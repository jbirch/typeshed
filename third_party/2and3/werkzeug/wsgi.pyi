import io
from typing import Any, Iterable, Optional, Sequence, Text, Tuple, Union, NoReturn

from werkzeug._types import AnyCallable, Iter, NoArgCallable, Readable
from wsgiref.types import InputStream, WSGIEnvironment, _Readable

# TODO: Would be awesome to constrain the return Callable signature to the same as that which was provided. Possible?
def responder(f: AnyCallable) -> AnyCallable: ...
def get_current_url(environ: WSGIEnvironment, root_only: bool = ..., strip_querystring: bool = ...,
                    host_only: bool = ..., trusted_hosts: Optional[Sequence[Text]] = ...) -> Text: ...
def host_is_trusted(hostname: Text, trusted_list: Sequence[Text]) -> bool: ...
def get_host(environ: WSGIEnvironment, trusted_hosts: Optional[Sequence[Text]] = ...) -> Text: ...
def get_content_length(environ: WSGIEnvironment) -> Optional[int]: ...
def get_input_stream(environ: WSGIEnvironment, safe_fallback: bool = ...) -> InputStream: ...
def get_query_string(environ: WSGIEnvironment) -> Text: ...
def get_path_info(environ: WSGIEnvironment, charset: Text = ..., errors: Text = ...) -> Text: ...
def get_script_name(environ: WSGIEnvironment, charset: Text = ..., errors: Text = ...) -> Text: ...
def pop_path_info(environ: WSGIEnvironment, charset: Text = ..., errors: Text = ...) -> Text: ...
def peek_path_info(environ: WSGIEnvironment, charset: Text = ..., errors: Text = ...) -> Text: ...
def extract_path_info(environ_or_baseurl: Union[WSGIEnvironment, Text], path_or_url: Union[Tuple[Text], Text],
                      charset: Text = ..., errors: Text = ..., collapse_http_schemes: bool = ...) -> Optional[Text]: ...

# TODO: Is it possible to genericise ClosingIterator and Iter on _T to constrain the return of `__next__`?
class ClosingIterator:
    def __init__(self, iterable: Iter, callbacks: Optional[Sequence[NoArgCallable]] = ...) -> None: ...
    # TODO: Is it correct to list a builtin to return itself? If we can genericise, can we just extend Iterator?
    def __iter__(self) -> ClosingIterator: ...
    def __next__(self): ...
    def close(self) -> NoReturn: ...

def wrap_file(environ: WSGIEnvironment, file: Readable, buffer_size: int = ...) -> Readable: ...

# TODO: Is it possible to genericise FileWrapper and the wrapped file-like to constrain the return of`__next__`?
class FileWrapper:
    # TODO: `_Readable` isn't quite right here; `__next__` expects `read(...) -> Optional[...]`
    file: _Readable = ...
    buffer_size: int = ...
    def __init__(self, file: _Readable, buffer_size: int = ...) -> None: ...
    def close(self) -> NoReturn: ...
    def seekable(self) -> bool: ...
    def seek(self, *args: object) -> NoReturn: ...
    def tell(self) -> Optional[int]: ...
    # TODO: Is it correct to list a builtin to return itself? If we can genericise, can we just extend Iterator?
    def __iter__(self) -> FileWrapper: ...
    # TODO: This won't be `Text` if the file-like doesn't return Text. If current `_Readable`, this is `bytes`.
    def __next__(self) -> Text: ...

# TODO: Is it possible to genericise _RangeWrapper and Iter on _T to constrain the return of `__next__`?
class _RangeWrapper:
    iterable: Iter = ...
    byte_range: Optional[int] = ...
    start_byte: int = ...
    end_byte: Optional[int] = ...
    read_length: int = ...
    seekable: bool = ...
    end_reached: bool = ...
    def __init__(self, iterable: Iter, start_byte: int = ...,
                 byte_range: Optional[int] = ...) -> None: ...
    # TODO: Is it correct to list a builtin to return itself? If we can genericise, can we just extend Iterator?
    def __iter__(self) -> _RangeWrapper: ...
    def __next__(self): ...
    def close(self) -> NoReturn: ...

# TODO: Can we constrain the Iterable return any further?
def make_line_iter(stream: Union[InputStream, Iterable[Any]], limit: Optional[int] = ...,
                   buffer_size: int = ..., cap_at_buffer: bool = ...) -> Iterable[Any]: ...
# TODO: Can we constrain the Iterable return any further?
def make_chunk_iter(stream: Union[InputStream, Iterable[Any]], separator: Text,
                    limit: Optional[int] = ..., buffer_size: int = ...,
                    cap_at_buffer: bool = ...) -> Iterable[Any]: ...

class LimitedStream(io.IOBase, Readable):
    limit: int = ...
    def __init__(self, stream: InputStream, limit: int) -> None: ...
    # TODO: Is it correct to list a builtin to return itself? If we can genericise, can we just extend Iterator?
    def __iter__(self) -> LimitedStream: ...
    @property
    def is_exhausted(self) -> bool: ...
    def on_exhausted(self) -> Text: ...
    def on_disconnect(self) -> NoReturn: ...
    def exhaust(self, chunk_size: int = ...) -> NoReturn: ...
    # def read(self, size: Optional[int] = ...) -> Optional[Text]: ...
    # def readline(self, size: Optional[int] = ...) -> Optional[Text]: ...
    def readlines(self, size: Optional[int] = ...) -> Sequence[Optional[Text]]: ...
    def tell(self) -> int: ...
    # TODO: This must be something text-like if it conforms to PEP 3333, but nothing here requires it...
    def __next__(self) -> Optional[Text]: ...
    def readable(self) -> bool: ...
